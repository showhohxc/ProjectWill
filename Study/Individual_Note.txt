
- Unity GameFlow Asset 
- FrameWork 설계능력 향상 필요....
- OpenSV 4.0 Visual 2008 호환 분석

기능에 대한 검토 체크사항에 대해서 나열해 보면 다음과 같이 나열이 될 수 있을 것이다.
1. 시스템의 요구사항이 제대로 반영되었는가?
2. 시스템의 설계의 규격대로 구현되었는가?
3. 과도한 코딩을 하고 있지 않는가?
4. 같은 기능 구현을 더 단순하게 할 수 있는가?
5. 함수의 입출력 값은 명확한가?
6. 빌딩 블록들( 알고리즘, 자료구조, 데이터 타입, 템플릿, 라이브러리, API )등이 적절하게 사용되었는가?
7. 좋은 패턴과 추상화( 상태도, 모듈화 )등을 사용해서 구현하고 있는가?
8. 의존도가 높은 함수나 라이브러리 등의 의존관계에 대해서 별도 기술하고 있는가?
9. 함수의 반환(exit)은 한 곳에서 이루어지고 있는가?
10. 모든 변수는 사용 전에 초기화하고 있는가?
11. 사용하지 않는 변수가 있는가?
12. 하나의 함수는 하나의 기능만 수행하고 있는가?

아키텍처에 대한 검토를 잊으면  안 된다.

1. 함수의 길이는 적당한가? ( 화면을 넘기면  안 된다. )
2. 이 코드는 재사용이 가능한가?
3. 전역 변수는 최소로 사용하였는가?
4. 변수의 범위는 적절하게 선언되었는가?
5. 클래스와 함수가 관련된 기능끼리 그룹화가 되었는가? ( 응집도는 어떤가? )
6. 관련된 함수들이 흩어져 있지 않는가?
7. 중복된 함수나 클래스가 있지 않는가?
8. 코드가 이식성을 고려하여 작성되었는가? ( 프로세스의 특성을 받는 변수 타입이 고려되어있는가? )
9. 데이터에 맞게 타입이 구체적으로 선언되었는가?
10. If/else구분이 2단계 이상 중접되었다면 이를 함수로 더 구분하라
11. Switch/case문이 중첩되었다면 이를 더 구분하라
12. 리소스에 lock이 있다면, unlock은 반드시 이루어지는가?
13. 힙 메모리 할당과 해제는 항상 짝을 이루는가?
14. 스택 변수를 반환하고 있는가?
15. 외부/공개 라이브러리 사용하였을 경우에 MIT 라이선스를 확인했는가? GPL의 경우에는 관련된 영역에서만 사용해야 한다.
16. 블로킹 api호출시에 비동기적인 방식으로 처리하고 있는가?

당연하겠지만, 예외처리 관련 체크리스트도 제대로 검토해야 한다.

1. 입력 파라미터의 유효 범위는 체크하고 있는가?
2. 에러코드와 예외(exception)의 호출 함수는 분명하게 반환되고 있는가?
3. 호출 함수가 어려와 예외처리 코드를 가지고 있는가?
4. Null포인트와 음수가 처리되는 구조인가?
5. 에러코드에 대해서 명쾌하게 선언하고 처리하고 있는가?
6. switch문에 default가 존재하고, 예외처리를 하고 있는가?
7. 배열 사용시에 index범위를 체크하는가?
8. 포인트 사용시에 유요한 범위를 체크하는가?
9. Garbage collection을 제대로 하고 있는가?
10. 수학계 산시에 overflow, underflow가 발생할 가능성이 있는가?
11. 에러 조건이 체크되고 에러 발생 시 로깅 정보를 남기는가?
12. 에러 메시지와 에러코드가 에러의 의미를 잘  전달하는가?
13. Try/catch 에러 핸들링 사용방법은 적절하게 구현되었는가?

요즘 프로그램은 대부분 이벤트성으로 구동되지만, 시간의 흐름에 대한 체크는 프로그램의 뼈대를 이루게 된다. 이 부분에 대해서도 제대로 검토해야 한다.

1. 최악의 조건에 대해서 고려하였는가?
2. 무한루프와 재귀 함수는 특이사항이 아니라면 없어야 한다.
3. 재귀 함수 사용시에 call stack값의 최댓값이 고정되어 있는가?
4. 경쟁조건이 존재하는가?
5. 스레드는 정상 생성, 정상 동작하는 코드를 가지고 있는가?
6. 불필요한 최적화를 통해서 코드 가독성을 희생하였는가?
7. 임베디드의 경우에도 최적화가 매우 중요하지 않다면, 가독성을 더 중요하게 해야 한다

가장 중요한 검증과 시험에 대해서도 제대로 인지하여야 한다. 그리고, 테스트를 위해서 가능한 최대한 자동화를 하기 위한 방법들을 이용해야 한다.

1. 코드는 시험하기 쉽게 작성되었는가?
2. 단위 테스트가 쉽게 될 수 있는가?
3. 에러 핸들링 코드도 잘  테스트되었는가?
4. 컴파일, 링크 체크 시에 경고 메시지도 100% 처리하였는가?
5. 경계값, 음수값, 0/1등의 가독성이 떨어지는 코드에 대해서 충분하게 경계하고 있는가?
6. 테스트를 위한 fault 조건 재현을 쉽게 할 수 있는가?
7. 모든 인터페이스와 모든 예외 조건에 대해서 테스트 코드가 있는가?
8. 최악의 조건에서도 리소스 사용은 문제가 없는가?
9. 런타임 시의 오류와 로그에 대비한 시스템이 있는가?
10. 테스트를 위한 주석 코드가 존재하는가?

코드 인스펙션은 다음과 같은 6단계로 진행된다.

1. Planning
A. 계획 수립
2. Overview
A. 교육과 역할 정의
3. Preparation
A. 인터뷰와 필요한 문서 습득, 툴 환경 구축
4. Meeting(Inspection)
A. 각자의 역할대로 수행
5. Rework
A. 보고된 Defect 수정
6. Follow-up
A. 보고된 Defect가 수정되었는지 확인

==================================================================
// DATE : 19.08.~
// NAME : MR.HAK
// KIND : Unity3D 2018
==================================================================
Mathf.Abs : 절대값 리턴
  ㄴ ex) 3 => return 3 / -3 => return 3
Mathf.Clamp : 최소값 최대값 제한
  ㄴ ex) Mathf.Cllamp(float value, float Min, float Max)  // 현재 value값을 설정한 Min과 Max로 제한한다. // 각각 설정한 값보다 작거나 클경우 해당 값을 리턴
Mathf.SmoothDamp : 시간 내에 정해진 목표값으로 스무스하게 값을 변화
  ㄴ current : 현재 위치 / target : 타겟위치 / currentVelocity : 호출시마다 이 함수에 의해 변경되는 현재속도 / smoothTime : 현재 위치에서 목적 위치까지 이르는데 걸리는시간 vaule가 최소일수록 빠르게 도착 / maxSpeed : 스피드 상한치

- 동기 소켓 연결 완료
- 비동기 소켓 연결 완료
- 1(Server Host):n(Client) 연결 시도

public class MethodA {
  public void Init() {}
}

public class MethodB : MethodA {
  public new void Init() {}
}

** new 는 부모 메소드가 virtual 이거나 아니거나 상관이 없다.

==================================================================
// DATE : 19.05.02
// NAME : MR.HAK
// KIND : Unity3D 2018
==================================================================
- Unity Timeline
- DoTween

==================================================================
// DATE : 19.04.16
// NAME : MR.HAK
// KIND : Visual Studio 2015
==================================================================
- 책갈피 기능 활성화  :  https://shaeod.tistory.com/594

==================================================================
// DATE : 19.04.12
// NAME : MR.HAK
// KIND : C#, Unity
==================================================================
[C#] Abstract Class
- 추상클래스는 미완성 클래스를 말한다
  ㄴ 몸체없는 함수를 하나라도 포함하고 있는 클래스
  ㄴ 몸체없는 함수를 포함하고 있지 않더라도 클래스를 선언할때 abstract 키워드를 포함하고 있는경우

★ [Local]/[World] 좌표계의 차이점
   ㄴ Local 좌표계는 자신을 중심(0, 0, 0)으로 생각한 각각의 모델링에 대한 교유의 좌표이고 만약 부모가 있다면 부모객체의 좌표와의 거리를 나타낸다 == 상대좌표
   ㄴ World 좌표계는 절대좌표라고 하며 유니티 좌표상에서 정해져있는 원점(0, 0, 0)에 기준을 정한 좌표 유니티상에서 변하지 않고 Reset시 객체가 그 기준점으로 가게된다.
   
   ex) 
    Transform.localPosition -> Local 좌표계
    Transform.Posion() -> World 좌표계

==================================================================
// DATE : 19.04.11
// NAME : MR.HAK
// KIND : Disign Pattern
==================================================================
- Factory Method Pattern 예시
  => Instance 생성을 서브클래스로 위임
  => 동일한 속성을 가지는 여러종류의 타입들
  
- Template Method Pattern
  => 부모클래스에서 Template에 해당하는 메소드가 정의되어 있고 메소드 내용중 세부적인 기능의 정의는 추상메소드롤 남겨 놓고 자식클래스에서 세부기능을 구현해 템플릿을 완성

- StrategyPattern 예시
  => 게임 유저가 자신이 처한 상황에 따라 공격이나 행동하는 방식을 변경하고 싶을때 StartegyPattern 유용하다. // 전략을 쉽게 수정할수 있도록해주는 패턴
  => 각각을 캡슐화하여 교환해서 사용할 수 있도록 만든다.
  => 일반적으로 서브클래스를 만드는 방법을 대신하여 유연성을 극대화 시키는 용도로 사용
==================================================================
// DATE : 19.03.11
// NAME : MR.HAK
// KIND : C++ / Unity
==================================================================
where T_1 : class<T_1, T_2>   
ex) protected T_1 CreateObject()
  {
    T_1 newTemplateObj = new T_1();
    return newTemplateObj
  } 
  ===> 변수 형식의 인스턴스를 생성시 초기 제약 조건에 new() 제약조건이 존재하지 않으므로 생성해야한다.
=> 변경) Where T_1 : class<T_1, T_2> , new()

==================================================================
// DATE : 19.03.08
// NAME : MR.HAK
// KIND : C++ / Unity
==================================================================
- IComarable 인터페이스는 객체의 값 비교를 제공하기 위해 정의
  ㄴ ICompable 인터페이스는 자신과 입력 인자를 비교하여 결과를 반환하는 CompareTo 메소드를 약속하며 입력 인자 형식을 Object 형식으로 되어 있으므로 프로그램 목적에 맞게 예외처리 등을 이용하여 처리

- 프로젝트 분석
  OpjectPool/PoolObject의 상관관계 및 VFXController 의 대입

==================================================================
// DATE : 19.02.27
// NAME : MR.HAK
// KIND : C++
==================================================================
- Class::Class() : 변수_1(0), 변수_2(null), 변수_3(false)
  ㄴ 변수_1(0), 변수_2(null)은 초기화 리스트이고 0과 null로 초기화하는 역할을 가진다.
    ㄴ 1. 생성자 함수 {  } 내에서 초기화 하는것과, 2. 위의 방식으로 초기화 리스트를 사용하는 것의 차이는 
       ㄴ 1. 초기화 리스트에서 초기화를 하는 경우, 생성자가 호출될 때 객체의 생성과 초기화가 한번에 이루어 진다.
          2. 생성자 함수 { } 에서 초기화를 하는 경우, 객체가 생성되어 Default 생성자로 초기화된 상태에서 다시 한번 할당을 받게 된다.
            => 이 경우 Default 할당 - 유저할당의 2단계를 거치게 되서 오버헤드가 생긴다.
    - 초기화 리스트를 사용하는 상황
      1. Class가 Reference를 멤버로 가졌을 때
      2. non static const 멤버가 있을때
      3. Default 생성자가 없을 때
      4. Base Class를 초기화 할때
      5. 생성자 파라미터의 이름이 데이터 멤버랑 같을때
      
- assert (표현식)
  ㄴ 정해진 조건에 맞지 않을시 프로그램을 중단 == assert에 지정한 조건식이 false일때 프로그램을 중단 true일시 프로그램 계속 실행
  ㄴ NDEBUG 매크로가 정의되어 있을시 assert는 무시되면 VisualStudio에 Debug 에서만 동작하며 Release 모드에서 동작하지 않는다

==================================================================
// DATE : 19.02.26
// NAME : MR.HAK
// KIND : Unity C#
==================================================================
- 같은 쓰임새가 있는 프리팹의 경우 ex) Enemy_1, Enemy_2 
  ㄴ Animator override Controller
    ㄴ 같은 모델링의 Ani를 일일히 등록할 필요없이 Override Controller에등록시 통합 사용 및 관리를 할수 있다.
    
- UnityEvent // Scene에 저장할 수 있는 인수가 없는 영구적 콜백
  - AddListener   // UnityEvent에 비 지속성의 리스너를 추가
  - Invoke        // 모든 등록된(런타임 및 영구적) 콜백을 실행
  - Remove        // UnityEvent에 비 지속성 리스너를 삭제

==================================================================
// DATE : 19.02.13
// NAME : MR.HAK
// KIND : Unity C#
==================================================================
- Component 기반으로 클래스간의 관계를 정립
- 독자 Tool 제작

- 프레임워크 : 주로 프레임워크 쪽에서 사용자의 코드를 호출하는 구조로 동작 = 실행의 흐름에 대한 제어를 프레임워크가 담당하게 된다.
              ㄴ 많은 프레임워크는 템플릿 메소드 패턴 기반으로 만들어진 클래스를 서브클래싱 하여 사용한다.
- 라이브러리 : 유저의 코드가 라이브러리를 호출해서 사용하는 구조로 되어있다. 즉 코드의 흐름을 유저코드가 관장하고 있는것.
- CinemachineCamera 는 Unity2018 부터 사용이 가능
==================================================================
// DATE : 19.02.12
// NAME : MR.HAK
// KIND : Algorithm
========================================================= =========
§ A* Algorithm

F = G + H
G 시작노드 에서 현재노드 까지의 최단경로의 값
H 현재노드 에서 목표노드까지의 최단경로의 값
F 시작노드에서 목표노드까지 현재노드를 통해 갈수 있는 모든 가능한 경로 중 최단경로의 값

OpenList   : 길 찾기를 진행하면서 거리를 고려하게 되는 사각형들의 목록
ClosedList : 바로 위 OpenList에서 목적지까지 가는데에 가장 짧은 거리를 가진 사각형들의 목록
ParentNode : 노드들 마다 자신이 어디에 속해 있는지를 가르키는 노드 => 나중에 길찾기를 통해 목적지를 찾았을때 최단의 길을 찾기위해 필요.

1. 시작지점을 열린목록(OpenList)에 넣는다.
2. 열린목록에 있는 노드 중 1개를 빼서 여덟 방향 주변노드를 탐색 (평가함수 F=G+H 계산 & 부모노드 명시, 장애물과 닫힌목록은 제외)
3. 2 에서 뺀 노드를 닫힌목록에 삽입
4. 2 에서 탐색한 노드들을 열린 목록(queue)에 삽입

5. 열린 목록 중 가장 앞 노드를 빼버리고 그 노드를 닫힌 목록에 추가한다. (우선순위 큐는 가장 작은 값부터 순서대로 정렬되는 특성으로 인해 낮은 F 비용을 가진 노드를 서치)
6. 5 에서 뺀 노드의 여덟방향 주요 노드를 탐색 (장애물 닫힌 목록 제외, 목표 노드가 있는지 조사)
  ㄴ End 조건 : 1. 만일 목표노드가 있을시 부모노드를 추적하여 역순으로 스택에 삽입
                2. 열린 목록이 비어있을시 목표노드를 찾는데 실패한 것이다. 길이 없음
7. 열린목록에 존재하지 않는 노드는 열린목록에 추가하고 중복되는 노드는 G값을 서로 비교하여 더 작은값을 정렬 교체
8. 5 부터 싸이클
==================================================================
// DATE : 19.02.11
// NAME : MR.HAK
// KIND : C++
==================================================================
Programming Terms
- 전위 버퍼(Primary Buffer)
  전위면이라고도 한다. 전위 버퍼는 화면과 1:1 대응되는 메모리를 말하며 그래픽 카드의 메인 메모리의 일부분이다.
  ex) 모니터의 해상도를 1024*768 -> 1920*1080 으로 변경시 이 전위버퍼에 해당되는 메모리 또한 늘어난게 된다. also 한점의 색상을 출력하기 위한
  비트수가 16비트 or 32비트인가에 따라서도 크기는 달라진다.
  전위 버퍼에 저자오디는 모든 데이터는 색상 정보이며 모니터는 이 전위 버퍼의 내용을 그대로 색상으로 출력한다.

- 후위 버퍼(Back Buffer)
  전위 버퍼와 동일한 특성을 가진 메모리를 말한다. 전위 버퍼가 모니터와 일대일 대응되므로 컴퓨터를 동작함과 동시에 그래픽 카드에 생성이 되지만 후위버퍼는 따로 생성
  그래픽 카드 메모리에 생성될수 있지만 시스템 메모리에도 생성이 될 수 있다. 
  후위 버퍼는 전위 버퍼와 특성이 같으므로 전위 버퍼와 연결하여 사용하며 주로 시스템 메모리 보다는 그래픽 카드 메모리에 생성하여 빠른 화면 전환을 하기 위해 사용된다.
  
- 이중 버퍼링(Double Buffering)
  두 개의 버퍼를 이용한 화면을 전환하는 방법
  후위 버퍼의 내용을 전위 버퍼에 복사하여 출력하는 것을 이중 버퍼링이라고 한다.
  -> 전위 버퍼가 모니터와 일대일 대응되고 있는 순간에 전위 버퍼의 내용을 변경시 변경된 내용의 일부만 보여지거나 깜빡임 or 화면이 찢어지는 테어링 현상이 발생된다.
     또한 모니터의 화면 속도와 메모리간의 속도차이로 이런 현상이 발생하기도  한다.
     이 현상을 줄이기 위해 백버퍼에 다음에 그려질 모든 내용을 미리 그려놓고 전위 버퍼에 한꺼번에 복사하는 방식을 사용한다.
     이 복사 방식은 메모리와 메모리간의 복사이므로 앞에 언급한 티어링 현상과 깜빡임을 상당히 줄여준다.
     
FrameWork Code
- 코드를 작성하기 위해 제공되는 프로그래밍 틀 
    => 프로그래머의 의도에 따라 아무 곳에서나 프로그래밍을 하는 것이 아니라 정해진 구조 안에 정해진 내용의 코드를 작성하는 구조를 말한다.
  잘만들어진 프레임워크는 팀 전체의 코드 통합과 향상을 가져온다.
    => 통합된 구조 안에서 작성한 코드는 구조의 역할에 따라 코드가 나눠지므로 개개인의 코드를 하나로 통합하기가 쉽다.
      => 팀단위로 프로그램을 만들시 상당히 유용하게 사용된다.
  ex) 대표적 FrameWork MFC / OWL    클래스 라이브러리로 구성

- 프레임워크를 활용하기 위한 지름길
  숙련된 프레임워크 숙련자 일수록 자신이 오랫동안 써 온 기능외에 관심을 두지 않아 유용한 라이브러리 기능을 놓치는 함정에 빠지기 쉽기 때문에 
  레퍼런스 메뉴얼과 API/클래스 문서를 살펴보고 유용한 라이브러리 기능에 대한 지식을 쌓는것이 프레임워크를 향상시키기 위한 지름길 
  
MVVM(Model + View + ViewModel)  - Unity 에 어떻게 적용하지????
  - 실질적인 사용자들의 눈 = View
    DB 통신하는 역할 Model 
    둘 사이에 View 와는 Binding or Command Pattern 으로 연결하고 Model 과는 데이터를 주고 받는 역할을 담당하는 ViewModel 라고 이해하면 된다
  
게임 오브젝트의 기본 구조 설계
  1. 공통된 부분들을 묶어서 계층을 추가하여 설계해 나가는 방식이 계층 구조를 사용한 게임 오브젝트 설계 방식
  2. 컴포넌트 기반 게임 오브젝트 설계
    ㄴ 게임 오브젝트가 해야 할 기능들을 각각 별도의 객체로 생성하여 게임 오브젝트에 연결하는 방식으로 
       게임 오브젝트의 클래스 폭발과 비대화 등의 문제점들을 해결할수 있는 설계 방식.
       = Object 마다 필요한 기능이 있을시 그 기능을 사용할 수 있도록 하는 것.. 실제 게임 Object Class 는 주로 컴포넌트들의 관리를 한다.
    ㄴ GameObject를 계충구조를 제작하는 것이 아닌 하나의 기능을 담당하는 컴포넌트를 계층구조로 만들어 복잡도를 낮추고 효율적으로 만들 수 있다.
  
==================================================================
// DATE : 18.12.05
// NAME : MR.HAK
// KIND : C++
==================================================================
포인터 사용이유
1. 변수의 지역성
2. 연속된 메모리 참조
3. 힙 영역 참조
4. 재귀적 자료구조 표현

==================================================================
// DATE : 18.11.29
// NAME : MR.HAK
// KIND : C#
==================================================================
버튼을 계속 누르는 경우
- 게이지 차징
- 툴팁 보이기

유니티가 제공하는 인터페이스주에 IPointerDownHandler, IPointUpHandler 인터페이스를 사용함으로 버튼이 누르고 있을시 특정 기능을 수행이 가능
* public void OnPointerDown(PointerEventData eventData) : 버튼을 클릭 하는 순간 실행
* public void OnPointerUp (PointerEventData eventData) : 버튼 클릭 떼는 순간 실행
=> OnPointerDown() 메소드 자체는 프레임마다 반복해서 발동하지 않는다. 오직 1번만 발동, 그러므로 bool 변수와 Update()메소드를 함께 사용해야한다.

==================================================================
// DATE : 18.11.27
// NAME : MR.HAK
// KIND : C#
==================================================================
Unity Pause and Resume
Time.timeScale = 0;   // Pause
Time.timeScale = 1;   // Resume

Time.timeScale
- Time.timeScale 프로퍼티는 시간이 어떤 속도로 흘러가는지를 의미 == value 1.0f라면 현재 유니티 씬의 시간이 실제 시간으로 흐름
  0.5f시 시간이 흐르는 속도가 절반  0.0f 시 GameObject == Pause State 상태 구현
  Time.timeScale 프로퍼티는 정적 프로퍼티이기 때문에 모든 씬의 게임오브젝트들이 공유, 
  그러므로 Time.timeScale 값을 변경시 씬의 모든 게임오브젝트가 영향을 받기 때문에 무분별한 사용 제한
- Time.fixedDeltaTime도 같이 수정
  Time.timeScale 을 수정시 Time.fixedDeltaTime도 같이 수정하길 권장
  "Time.fixedDeltaTime = 0.02f * Time.timeTimeScale" 코드는 유니티에서 물리 연산을 담당하는 < 별도의 타이머로 동작> 하기 때문에
  Time.timeScale에 변화를 주었다면 Time.fixedDeltaTime 또한 수정
- 특정 오브젝트의 TimeScale만 수정하려면?
  1. Mecanim Animation : Animator.speed라는 프로퍼티를 이용하여 value값을 조정
  2. Rigidbody : 힘을 가해주는 Rigidbody.AddForce(), 토크를 가해주는( 각속도를 변화시키는 Rigidbody.AddTorque() 메소드등의 패러미터값을 조절)
  3. Transform : Transform.Translate(), Transform.Rotate() 메소드 등의 패러미터 값을 조절
- 정리
  1. Time.timeScale 프로퍼티는 모든 게임오브젝트의 시간 어떤 속도로 흘러가는지를 나타낸다. 기본값은 1.0f이다.
  2. Time.timeScale 프로퍼티를 바꾸었다면 Time.fixedDeltaTime 역시 바꾸는 것이 좋다. (Time.fixedDeltaTime = 0.02f * Time.timeScale)
  3. 예를 들어 Time.timeScale 프로퍼티가 0.0f이면 정지/포즈 상태를, 2.0f이면 2배로 시간이 빨리 흘러가는 것을 구현할 수 있다.
  4. 특정 게임오브젝트의 타임스케일을 바꾸기 위해서는 각 컴포넌트(Animator, Rigidbody, Transform 등)에 맞는 방법을 사용해야 한다.
  
==================================================================
// DATE : 18.11.26 
// NAME : MR.HAK
// KIND : C#
==================================================================
Collision 직전 체크 / BeforeCollision
- Collision이 발생하기 직전에 뭔가를 체크하고 싶을 때 Collider가 있는 오브젝트에 해당 Collider 봐 조금 큰 Collider을 만들고 is Trigger 체크
  그리고 스크립트에서 OnTriggerEnter2D 이벤트에서 체크할 내용을 처리해주면 된다.
  
Unity 2017.3.ver
오브젝트간 움직임을 연결

1) 부모, 자식으로 세팅
- 부모, 자식에게 모두 Rigidbody가 있는 경우 자식의 Collider는 동작하지 않는다. ( Trigger는 동작 )
- 자식 Rigidbody는 Kinematic 이어야한다. ( or simulated = false )
- 부모가 flip( =localScale 변경, 좌우상하 대칭 )되는 경우, 자식의 localScale은 그대로 유지되므로, 
  부모-자식 관계가 끝났을때 palyer의 방향에 따라 자식의 방향을 바꿔줘야 한다면, 자식에게 dettach될때 localScale 변경처리 필요
- 처리방법:
  A. Player의 자식으로 빈 게임오브젝트 생성하여 박스가 위치할 Position 세팅
  B. box 오브젝트의 Position을 boxPos Position으로 변경
  C. SetParent(boxPos) 이용하여 부모세팅
==================================================================
// DATE : 18.11.19
// NAME : MR.HAK
// KIND : C#
==================================================================
static function Raycast (origin : Vector3, direction : Vector3, distance : float = Mathf.Infinity, layerMask : int = kDefaultRaycastLayers) : bool
파라미터
origin	월드 좌표계에서 레이의 스타팅 포인트입니다.
direction	레이의 방향입니다.
distance	레이의 길이 입니다.
layerMask	Layer mask는 ray를 발사시 선택적으로 특정 컬라이더를 무시할때 사용합니다.

==================================================================
// DATE : 18.11.15
// NAME : MR.HAK
// KIND : C#
==================================================================
HashTable vs Dictionary
1. Non-Generic ex) List
2. Key and Value 모두 Object를 입력받는다.
3. Boxing/UnBoxing 사용
== 제네릭을 이용하지 않고 Object를 사용하기 때문에 모든 데이터 타입을 다받고 처리할수 있지만
   자료의 입력에 내부적으로 박싱 발생하여 발생하는 곳에서 다시 언박싱 처리를 해줘야 한다. ex) as TypeClass (언박싱 처리)
HashTable  : Null 허용 X 
HashMap    : Null 허용

Dicitonary<TKey, TValue>.ContainsKey : 지정된 키가 붙어있는지 여부 확인.
1. Generic
2. Key and Value 모두 Strong Type을 입력받는다 (선언시 타입을 입력)
3. 박싱 언박싱이 일어나지 않는다.

// 결론
필요에 따라 선택을 해야한다.
= 고정적으로 하나의 타입만 입력받을시 Dictionary
= Value에 일정한 형식이 없고 여러 형태를 저장시 HashTable

==================================================================
// DATE : 18.11.14
// NAME : MR.HAK
// KIND : C++ STL 
==================================================================
해싱, 해시함수, 해시테이블 이해
  ㄴ 모든 숫자들의 이해...
  ㄴ 컴퓨터 구조 파악

Hash Function
데이터의 효율적 관리를 목적으로 임이의 길이의 데이터를 고정된 길이의 데이터로 변환(mapping)하는 함수.
  ㄴ 매핑 전 원래 데이터값을 키(Key), 매핑 후 데이터의 값을 해시값(Hash Value), 매핑하는 과정 자체를 해싱(Hashing)라고 한다.
  
Hash Table의 장점
해시충돌이 발생할 가능성을 놓고도 해시테이블을 사용하는 이유는 간단하다. ★[ 적은 리소스로 많은 데이터를 효율적으로 관리하기 위해서다. ]
  ㄴ 해시함수로 HDD나 클라우드에 존재하는 무한에 가까운 데이터(Key)들을 유한한 개수의 해시값으로 매핑함으로 작은 크기의 캐쉬 메모리로도 프로세스를 관리할수 있게 된다.
1. Index에 해시값을 사용함으로 모든 데이터를 살피지 않아도 검색과 삽입/삭제를 빠르게 수행이 가능하다.
2. 해시 함수는 언제나 동일한 해시값을 리턴, 해당 색인만 알면 해시테이블 크기에 상관없이 데이터에 대단히 빠르게 접근가능,
   색인은 계산이 간단한 함수(상수시간)로 작동하기 때문에 매우 효율적, == 해시는 데이터액세스(삽입,삭제,탐색)시 계산복장성을 O(1)을 지향.
3. 보안분야 특화. 키와 해시값 사이에 직접적인 연관이 없기때문에 해시값만 가지고 키를 온전히 복원이 난해, 해시함수는 길이가 서로 다른 입력데이터에 대해 일정한 길이의 출력만 만들수 있어서 '데이터 축약'기능도 수행 가능

Hash Table
해시함수를 사용하여 키를 해시값으로 매핑하고, 이 해시값을 색인(Index) or 주소 삼아 데이터값(value)을 키와 함께 저장하는 자료구조를 해시테이블(Hash Table)이라고 한다.
이 때 저장되는 곳을 버킷(bucket) or 슬롯(slot)라고 한다. 해시테이블의 기본 연산은 삽입,삭제,탐색(search)이다.

보통의 경우 Direct Address Table 보다는 해시테이블 크기(m)가 실제 사용하는 키 갯수 (n) 적은 해시테이블을 운용
다뤄야할 데이터가 많고 메모리등 리소스문제도 생기기 때문에 이때 n/m을 load factor(a)라고 하고. 해시테이블의 하 버킷에 평균 몇개의 키가 매핑되는가를 나타내는 지표
== Direct Address Table의 load factor는 1 이하며, 1 보다 큰경우 해시충돌 문제가 발생
  ㄴ 보완 : chining은 해시테이블의 크기를 유연하게 만들고 open addressing는 해시테이블 크기를 고정시키되 저장해 둘 위치를 찾는데 관심을 둔 구조.
  
chaining
해시충돌 문제를 해결하기 위한 간단한 아이디어 가운데 하나는 한 버킷당 들어갈수 있는 엔트리의 수에 제한을 두지 않음으로 모든 자료를 해시테이블 담는것이다.
해당 버킷에 데이터가 이미 있다면 체인처럼 노드를 추가하여 다음 노드를 가르키는 방식으로 연결리스트를 이용한 구현한다,
유연하다는 장점을 가지나 메모리 문제를 야기 할 수 있다.

open Addressing
chaining와 달리 한 버킷당 들어갈 수 있는 엔트리가 하나뿐인 해시테이블이며
 [ 해시 함수로 얻은 주소가 아닌,다른 주소에 데이터를 저장할 수 있도록 허용한다는 취지에서 open Addressing ]
  ㄴ 메모리 문제가 발생하지 않으나 해시충돌이 생길수도 있다.

probing
특정 해시값에 키가 몰릴시 open addressing 의 효율성이 크게 떨어진다. 해시충돌은 탐사(probing) 방식으로 해결 가능
탐사란 삽입, 삭제, 탐색을 수행하기 위해 해시테이블 내 새로운 주소(해시값)을 찾는 과정
선형탐사(Linear probing) - 최초 해시값에 해당하는 버킷에 다른 데이터가 저장돼 있으면 해당 해시값에 고정 폭을 옮겨 
다음 해시값에 해당하는 버킷에 액세스(삽입,삭제,탐색) 한다. 여기에 데이터가 있으면 고정폭으로 또 옮겨 액세스한다.
    => 검색을 할시, Key 가 일치하지 않을시 뒤의 Index를 검색해서 같은 키가 나오거나 or Key가 없을때 까지 검색을 진행한다.
  
해시함수
= 해시충돌을 완화하는 방법 
해시테이블의 크기가 m이라면, 좋은 해시함수는 임의의 키값을 임의의 해시값에 매핑할 확률이 1/m 이 될것이고 이는 특정값에 치우치지 않고 
해시값을 고르게 만들어내는 해시함수가 좋은 해시함수라는 이야기이다.
/*
  String str_Key;
  char[] chMsg = str_Key.toChar();
  int nHash = 0;
  for(int i = 0; i < str_Key.Length; ++i)
    nHash = nHash *31 + char[i];
*/

map, set / Hash_map, Hash_set
map, set            컨테이너는 자료를 정렬하여 저장  => 반복자로 저장시 데이터를 순회시 넣은 순서로 순회하지 않고 정렬된 순서대로 순회
Hash_map, Hash_set  정렬 하지 않고 자료를 저장 => Hash라는 자료구조를 사용함으로 검색속도가 map, set에 비해 빠르다.

Hash_map 사용 시기
해시테이블을 자료구조로 사용하므로 해시테이블에 대해 알면 장단점을 파악이 가능
장점 : 많은 자료를 저장하고 있어도 검색이 빠름,
단점 : 저장한 자료가 적을시 메모리 낭비와 검색시 오버헤드가 발생

컨테이너에 추가나 삭제를 하는것은 list나 vector, deque가 hash_map 보다 빠름
적은 요소를 저장하고 검색시 vector나 list가 훨씬빠름
수천의 자료를 저장하여 검색을 하는경우에 hash_map을 사용하는것이 좋다.
=> 많은 자료를 저장하고 검색속도가 빨라야한다 / 너무 빈번한 자료를 삽입, 삭제 하지 않는다.

==================================================================
// DATE : 18.11.08
// NAME : MR.HAK
// KIND : C++
==================================================================
map<Index, Value> STL 자료형 특징
- 첫 번째 요소는 first 로써 Index이고, second로써 Data이다. 인덱스와 데이터가 분리된 상태이며 독립적으로 자료형을 지정해줄 수 있다.
- 반복자(iterator)외 배열 첨자를 사용하여 접근할 수 있다.
- 자동적으로 정렬된 상태를 유지, if 정렬할수 없을시 출력순서는 먼저 입력된 것이 가장 나중에 출력된다.
- Index가 중복되서 추가시, 기존의 데이터는 없어지고 새로운 데이터로 덮어씌여진다.
- Template를 사용하여, 인덱스나 데이터나 형식에 대하여 자유롭다.

A* Algorithm
F = G + H
G 시작노드 에서 현재노드 까지의 최단경로의 값
H 현재노드 에서 목표노드까지의 최단경로의 값
F 시작노드에서 목표노드까지 현재노드를 통해 갈수 있는 모든 가능한 경로 중 최단경로의 값

1. 시작지점을 열린목록(OpenList)에 넣는다.
2. 열린목록에 있는 노드 중 1개를 빼서 여덟 방향 주변노드를 탐색 (평가함수 F=G+H 계산 & 부모노드 명시, 장애물과 닫힌목록은 제외)
3. 2 에서 뺀 노드를 닫힌목록에 삽입
4. 2 에서 탐색한 노드들을 열린 목록(queue)에 삽입

5. 열린 목록 중 가장 앞 노드를 빼버리고 그 노드를 닫힌 목록에 추가한다. (우선순위 큐는 가장 작은 값부터 순서대로 정렬되는 특성으로 인해 낮은 F 비용을 가진 노드를 서치)
6. 5 에서 뺀 노드의 여덟방향 주요 노드를 탐색 (장애물 닫힌 목록 제외, 목표 노드가 있는지 조사)
  ㄴ End 조건 : 1. 만일 목표노드가 있을시 부모노드를 추적하여 역순으로 스택에 삽입
                2. 열린 목록이 비어있을시 목표노드를 찾는데 실패한 것이다. 길이 없음
7. 열린목록에 존재하지 않는 노드는 열린목록에 추가하고 중복되는 노드는 G값을 서로 비교하여 더 작은값을 정렬 교체
8. 5 부터 싸이클

==================================================================
// DATE : 18.11.05
// NAME : MR.HAK
// KIND : C#
==================================================================
Queue : FIFO 선입선출 방식의 데이터 구조
Enqueue : 데이터를 입력하는 함수
Dequeue : 데이터를 출력하는 함수


==================================================================
// DATE : 18.11.02
// NAME : MR.HAK
// KIND : C#
==================================================================
- 메모리 힙 영역
  프로그램이 돌아가면서 생성되는 값들은 메모리 힙영역에 할당된다. == ( 동적 메모리 할당 )
  메모리 할당 요청이 발생시 힙 메모리를 관리하는 관리자가 필요한 만큼의 영역을 힙에 예약, 예약된 영역은 다른 값이 할당될 수 없는 곳이 된다.
  예약된 곳을 핸들러나 포인터를 반환하여 값을 할당하는 등의 접근이 가능하게 된다.
  
- 누수 현상
  오류로 인한 영역을 가르키는 포인터 반환이 안된경우 or 영역의 예약이 잘못 된 경우, 등으로 해당 힙 영역을 사용하지 못하게 된다. == 메모리 누수 현상
  문제가 되는 이 영역은 다시 사용할 수 있도록 예약 해제가 되어야 하는데 그래야 다시 사용 할수 있는 상태가 되기 때문, 사용되지 않은 영역이 쌓이다 보면 프로그램이 멈춘다.
  00000
- 오브젝트 생성 파괴
  짧은 시간에 많은 오브젝트의 생성과 파괴는 게임 시간이 길어질 수록 많은 자원을 사용하여 배터리 소모 or 발열의 원인 
  힙 메모리를 짧은 시간에 자주 할당함으로 가비지가 쌓인다.

- 병목현상
  게임 중 화면에 표시할 오브젝트가 많아서 DrawCall 도 많아짐 CPU에서 정보들을 빠르게 연산하여 GPU에 넘겨줘야 하는데
  오브젝트가 너무 많아 신속하게 처리가 안된다. 이러한 병목현상이 나타날시 갑자기 화면이 멈춘것 처럼 보이거나 끊기는 현상이 발생
  CPU 부담이 커지고 열이많아져 배터리 소모가 심하고 이렇게 지체된 시간을 오버헤드( OverHead ) 라고 한다.
  
- [Serializable]
  클래스나 오브젝트를 스트링이나 일차원 배열형태로 변환하는것. 스크립트에서 만든 클래스의 각종 변수들을 한줄로 늘어서게 한것.
  한줄로 세워놓을시 Data를 컴퓨터의 저장장치에 저장 하거나 네트워크로 전달하기에 편리. Object or Class를 한줄로 직렬화 해주는 것
  < static, const, readonly, fieldtype > / 추상클래스 등 직렬화가 불가능
  
- Distance Magnitude( 거리 크기 구하기 )  A 좌표와 B좌표간의 거리를 구할시 ( C = A - B ) 의 Magnitude 값을 획득 == Vector3.Distance(A,B)
  But, 담 루트 연산을 하기 때문 많은 적들이 있을시 매 프레임마다 Magnitude 연산을 해야 하기때문에 Cpu에 부담
  Therefore 단순한 두 오브젝트 간 거리를 비교하고자 한다면 루트연산을 하지 않고 값만은 반환하는 sqrMagnitude를 사용 
  sqrMagnitude 값이 크다는것은 거리가 멀다는 것이기 때문에 이것으로 거리를 비교  == 두 좌표를 비교하지 않고 벡터의 각 요소에 제곱하여 더한 값으로
  단순 값으로 크기에 크면 멀게 크리가 작으면 가깝게 비교
  
  어쩔 수 없이 멀티 쓰레드를 사용하는 경우

게임을 만드는 도중 여러 플러그인들을 사용하게 된다. 광고,결제,통계,소셜 등등.. 
많은 플러그인들의 서비스가 돌아갈 때 각자의 쓰레드를 사용하는 경우가 많다. 
또는 게임서버와 소켓 통신을 하는 경우 소켓 라이브러리를 사용해야한다. 
게임서버와 소켓 라이브러리를 사용하여 소켓통신하는 경우를 예로 들어보자. 
소켓 라이브러리는 서버와 통신하는 로직을 별도의 쓰레드를 돌려서 사용한다. 
소켓을 통해 게임서버와 데이터를 주고 받는 과정이 이 쓰레드에서 처리된다. 
그런데 주고받은 데이터를 UI에 표시하거나 게임에서 사용하려고 할 때 에러가 발생한다. 
유니티의 UI나 리소스는 메인 쓰레드 이외에 다른 쓰레드에서는 사용할 수 없기 때문이다.


==================================================================
// DATE : 18.11.01
// NAME : MR.HAK
// KIND : C++
==================================================================
Template Defintion
- 오버로딩을 활용하기 위한 것으로 기능은 결정되어 있으나 자료형이 정해지지 않은것
== 무엇을 만들기위해 찍어내는 틀
  함수 탬플릿 or 클래스 탬플릿으로 구분

- 함수 템플릿 - 컴파일시 사용한 데이터 타입으로 함수가 만들어짐
  Template < typename T >
  void Swap(T &num_1, T &num_2)
  
- 클래스 템플릿 - 템플릿 인자로 넘어온 자료형을 적용하여 새로운 클래스를 하나 생성한다.
==================================================================
// DATE : 18.10.30
// NAME : MR.HAK
// KIND : C++
==================================================================
연산자 오버로딩
C++ 에서 연산자가 하는일을 함수로 개인의 필요에 맞게 구현한 것
클래스의 성격에 따라 필요한 연산 기능이 있다면 그에 맞게 동작하도록 기본 연산자 기능을 재정의할 필요가 있는데 이것을 연산자 오버로딩이라 한다.

오버로딩한 함수는 operator<연산자>형태의 이름을 가지고 있다. 이항 연산자의 경우 좌측의 피연산자는 호출할 객체가 되며, 우측의 피연산자는 인수가 된다.
-임시객체
  예제에 real, imag 변수를 만들고 이를 Complex라는 임시객체에 담아 리턴했는데, 리턴한후 임시객체는 소멸한다.
  임시객체를 사용할 겨우 최적화가 진행되 속도가 빨라지기 때문에 임시객체를 사용하는것이 효율적이다.
  
연산자 오버로딩 주의사항
- 기존 연산 방법을 바꿀수 없다.
  연산자 오버로딩을 할시 연산자들 중 적어도 하나는 객체가 되어야 한다.
  ㄴex) int operator+(int Left, int Right); 이와 같은 함수를 만들시 이는 정수의 덧셈방법을 변경할 수 있으므로 혼란 초래
  연산자의 우선 순위나 계산 순서를 변경하는것도 불가능
- 디폴트 매개 변수 설정이 불가능
- 기존 연사자의 기능을 해치지 말자
  ㄴ ex) +연산자를 -연사자 기능으로 만드는것은 말이 안된다. 오버로딩의 목적은 클래스의 편리한 사용과 이해하기 쉬운 코드에 있기 때문에..

- Class operator
  Car& operator=(const Car&)
==================================================================
// DATE : 18.10.30
// NAME : MR.HAK
// KIND : C#
==================================================================
- :virtual 키워드는 부모 클래스에서 함수를 가상으로 정의해 놓고, 실제로 구현은 자식 클래스에서 하고자 하는 경우에 사용하는것으로 이해하면 편리
- 복잡한 프로그램을 개발할때 일반적인말로 "컴포넌트화" 시켜서 모듈을 관리할때 이 virtual 키워드를 사용하는 것은 필수일 것
  ㄴ 일반적으로 모듈들은 하나의 공통된 부모 클래스를 두고 각각의 종류에 따라서 동작을 특성화 시켜서 변경하기 때문에 그럴때 virtual 키워드가 유용

==================================================================
// DATE : 18.10.25
// NAME : MR.HAK
// KIND : C++
==================================================================
C++
- .(레퍼런스) 과 ->(포인터) 차이 
  .  : 참조로 요소 선택 ( .앞에 변수나 포인터가 아닌 저장하려는 데이터가 있을때 사용 )
  -> : 포인터로 요소 선택 ( -> 앞에 포인터가 있을 경우 사용 )
  
★즉, 일반적인 구조체나 클래스 같은 사용자 정의 데이터 타입의 경우 동적으로 사용하겠다고 선언을 하지 않을 경우
  포인터를 사용하지 않아도 되므로 참조로 요소를 선택하고// 동적으로 사용할 경우 포인터가 필요하므로 포인터로 요소를 선택하는 -> 를 사용한다.

화살표 연산자는 점(.)을 먼저 역 참조한다는 점을 제외하고 점과 같다. foor.bar() 는 foo 객체의 메소드 bar()를 호출하고 
                                                                    foor->bar 는 포인터가 가르키는 객체의 메소드 bar를 호출.
object.Field  : . 연산자는 직접 멤버 액세스 용
pClass->Field : 화살표는 포인터를 역 참조하므로 포인터를 가르키는 객체 / 메모리에 액세스 할 수 있다.

★ 일반적인 struct나 class 같은 사용자 정의 데이터타입의 경우 동적으로 사용하겠다고 선언 하지 않을경우 포인터를 사용하지 않아도 된다.
참조로 요소를 선택하고 동적으로 사용할경우 포인터가 필요


Class와 include의 차이점
- Class로 선언하는 것을 파일을 포함하지 않고, 해당 파일을 사용할 것이라는 선언만해줌
  ㄴ Include로 선언하는 것은 해당파일을 그대록 복사해서 포함시킨다.
  
- Class의 경우 파일이 중복포함되는것을 방지
- Class의 경우 컴파일 시간이 줄어듬
- 객체를 선언하려면 반드시 Include를 해주어야 한다, - 해당 객체의 크기를 알아야 하기 때문이다. 포인터 선언시 Class를 사용하면된다.
==================================================================
// DATE : 18.10.24
// NAME : MR.HAK
// KIND : C#
==================================================================
- 코드 영역
  실제 프로그램 코드 자체가 적재되는 영역 갈발 언어는 컴퓨터가 이해할 수 있는 기계어의 형태로 컴파일 되어 파일 등에 저장되는데
  실제 이 파일의 프로그램에 대한 전체적인 코드 자체가 올라가는 영역 = 프로그램 자체 영역
  
- 데이터 영역
  프로그램이 실행되면서 필요한 변수가 저장되는 영역, 프로그램이 구동되는 동안 항상 접근 가능한 변수가 저장되는 영역 
  = 전역변수(Global Variables) / 정적변수(Static Variables)를 위한 할당 공간
  
- 스택영역(Stack)
  함수내에 정의된 지역 변수(Local Variables)가 저장되는 영역
  가장 마지막에 들어간 것이 먼저 나오는 구조인 LIFO (Last In, First Out) 형태를 가진 스택 구조를 이용하면 이러한 데이터 관리를 쉽게 구현할 수 있을 것으로 보입니다.  
  (함수 하나가 실행되면 해당 함수에서 사용되는 지역 변수의 메모리가 스택 영역에 쌓이고, 함수가 끝나면 해당 지역 변수는 더 이상 사용되지 않으므로 메모리에서 해제시킵니다.)
  이렇게 스택의 구조를 활용하여 함수의 지역 변수 메모리를 관리하면 위의 메커니즘을 쉽게 구현할 수 있기 때문에 스택 형태로 영역을 만들어 활용하였고, 그리하여 스택 영역(스택 세그먼트)라 이름이 붙었습니다.
  
- 힙영역(Heap)
  힙 영역은 위에서 관리가 가능한 데이터 외에 다른 형태의 데이터를 관리하기 위한 빈 공간(Free Space)입니다. 어떤 형태의 데이터가 있을까요? 바로 동적 할당(Dynamic Allocation)을 통해 생성된 동적 변수(Dynamic Variables)를 관리하기 위한 영역입니다.
  힙 영역은 위의 다른 영역(데이터, 스택 등)을 모두 할당하고 남은 공간입니다. (남은 공간이라하여 딱히 영역에 제한이 있거나 그런 것은 아니고, 시스템의 메모리 공간 여유에 따라서 달라집니다.)



==================================================================
// DATE : 18.10.22
// NAME : MR.HAK
// KIND : C#
==================================================================
- 설계는 고객의 요구를 수용하는 과정이다.
- 설계는 레고 블럭과도 같은 제작을 위해서다.
  ㄴ 프로그램 구조 설계나 모듈 트리 등은 필수
- 쉬운 인수인계( 유지보수 )

데이터 설계
- 데어터 설계 시 기본적으로 요구 사항 정의와 명세 부분에서 인식된 데이터 개체의 논리적 표현을 선택해야한다.
- 데이터 설계 원칙
  ㄴ 기능과 행위에 적용된 체계적 분석 원리들이 데이터에도 적용될 수 있어야 한다.
  ㄴ 모든 데이터 구조와 각각의 데이터에 대해 수행되는 연산들이 식별되어야 한다.
  ㄴ 데이터 구조는 데이터를 직접 이옹하는 모듈 안에서만 표현되어야 한다.
  ㄴ 소프트웨어 설계와 프로그래밍 언어는 추상 데이터 형태의 명세와 구현을 지원해야 한다.

아키텍처 설계
- 아키텍처 설계 목적
  ㄴ 모듈 프로그램 구조를 개발하고 모듈 간의 제어 관계를 표현
  ㄴ 프로그램과 데이터 구조를 형성하고 프로그램 전반에 걸친 데이터 흐름을 위한 인터페이스 가능 하게 한다.

인터페이스 설계
- 소프트웨어 모듈들 사이의 인터페이스 설계
- 소프트웨어와 정보의 다른 생산자 / 소비자(외부 개체) 사이의 인터페이스 설계
- 사용자와 컴퓨터 사이의 인터페이스 설계
-> 상속
GGCManagerSceneLoader -> CManagerSceneLoaderBase -> CStaticManagerTemplateBase -> CManagerBase -> IObjectBase
==================================================================
// DATE : 18.10.18
// NAME : MR.HAK
// KIND : C#
==================================================================
2D UI는 씬에 게임오브젝트가 생기는데, 여기엔 핵심적인 2개의 컴포넌트가 연결되어 있다.
1. UIRoot
위젯을 작업하기에 적합한 크기로 줄여주는 역할을 하고, Scaling Style를 담당한다.
Scaling Style에서 텍스처의 픽셀상의 본래 크기를 유지하는 Pixel perfect가 있고, 
파라미터에 지정한 값에 따라 화면에서 비율을 유지하는 방식인 FixedSize가 있다.

2. UICamera
버튼에 붙어있는 충돌체처럼, 각 UI요소에서 발생하는 이벤트와 관련된 메세지를 보내는것이 주된 기능이다.
OnClick()이나 OnHover()등의 메소드가 있다.
2. UICamera

파라미터
EventType : 카메라가 처리할 이벤트 유형을 결정한다.
EventMask : 이벤트를 받아들일 레이어를 지정한다.
Debug : 디버그 모드의 사용여부, UI가 의도하지 않은 방식으로 작동할 때, 유용하다.
AllowMultiTouch : 멀티 터치 입력의 허용 여부를 결정한다.
Sticky Tooltip : 사용여부 결정.
Raycast Range : 특정 지점에서 특정 방향으로 소는, 보이지 않는 가상의 선이다. 중간에 다른 오브젝트와 만날 경우 진행을 멈춘다. 충돌체를 감지한 카메라는 이벤트를 처리하기 위해 마우스나 터치 입력이 발생하는 지점에서부터 정면을 향해 가상선을 그린다. 이 때 가상선의 진행 범위를 제한하면 상호작용이 발생하는 영역을 한정 할 수 있다. 기본값이 -1을 사용하면 카메라가 볼 수 있는 영역까지 가상선의 범위가 미친다.

3. UIAnchor
카메라 뷰 상에서 게임오브젝트를 이정한 지점에 고정시키기 위해 사용한다.

4. UIPanel
Panel의 목적은 위젯을 모아서 관리하고, 하나의 드로우콜로 렌더링하는 것.

==================================================================
// DATE : 18.10.11
// NAME : MR.HAK
// KIND : C#
==================================================================
- default(T) : 형식 T의 기본값을 생성 다양한 형식에 대한 기본값 생성
ex) 
  임의 참조 : null
  숫자 값   : 0
  bool      : false
  char      : '\0'
  struct    : null
  nullable  : false


==================================================================
// DATE : 18.10.05
// NAME : MR.HAK
// KIND : C#
==================================================================
Scroll Wheel Factor : 마우스 스크롤 휠로 패널의 y축 상에서 드래그 할려고 할때 0이상의 값을 입력
Momentum Amount : 패널을 드래그해서 놓았을 때 적용할 탄력
Restrict within Panel : 스크롤 뷰의 내용이 스크롤 뷰 영역을 벗어나지 않게 제한
Cancel Drag if fits : 스크롤 뷰의 내용이 스크롤 뷰 영역을 벗어나지 않게 제한


==================================================================
// DATE : 18.09.28
// NAME : MR.HAK
// KIND : C#
==================================================================
코드 최적화
- Loop : Foreach는 속도 느림 가비지 남김 Enumerator는 foreach보다 빠르게 동작하며
         for는 Enumerator의 2배나 바르게 동작한다. => 즉, for이 가성비가 좋고 그렇지 않으면 Enumerator가 낫다.

- Parse : Tostring() / System.Conver.ToString() / Int.Parse / Int.TryParse 
          int->string은 작성자 뜻대로, string->int 는 tryParse가 낫다.
          
- String concat : + 연산자 / string.Concat / StringBuilder
                  StringBuilder가 속도가 좋고 가비지도 가장 적게 남긴다.

- CallBack : System.Action / System.Func<T> 빈 delegate를 작성하지 말고
             소스코드의 안정성과 속도를 위해 CallBack을 받는 부분에선 무조건 null 체크를 하고, null을 인자로 작성.
             
- transform caching : transform에 자주 접근하게 되는 객체에선 caching은 필수

- string compare : string.Compare / string.CompareTo / Equals / Operator / Hash Operator  
                   Operator > HashOperator > Equals > CompareTo > Compare  // Equals 사용 권장
                   
- Debug.Log : Log는 여러면에서 많은 비용을 차지한다 보안상 노출시키지 말고 프로그램 성능상 출력하지 말아야 하며 
              배포된 빌드에선 필수!! 로 막아야 한다. 즉, 로그를 삭제시키는 일은 선택이 아닌 필수..
==================================================================
// DATE : 18.09.19
// NAME : MR.HAK
// KIND : C#
==================================================================
% 괜찮은 Tool 개발.. Move Tool or Action Tool

C# Interface
  Class or Struct 로 구현할수 있는 규약을 정의함
  == < 특정 Class 에서는 반드시 특정한 기능>을 구현해야 한다는 규칙이 있는 경우 Interface를 구현하도록 강제하는 기능
      ex) public interface Car { void Drive(), void Run() }   // 특정 클래스에서 필수적인 것들...
      Interface는 메서도, 속성, 이벤트, 인덱서를 포함할 수 있으며 멤버의 기능을 구현하지 않는다. == 껍데기만 있는 상태
  Interface는 다중 상속이 가능하여 클래스의 단일 상속과는 다른데 하나의 클래스에서 다중 Interface를 구현 할 수 있다. 상속과는 다르다.     
  C# 은 명식적 인터페이스 멈버 구현을 지원하는데 보통 인터페이스를 구현하는 클래스에서는 인터페이스 Public으로 선언하여 공객적으로 사용해야한다.
  메소드가 감춰져 있기때문에 클래스에서는 접근이 불가능하다.  ex) void Class.Method ...
  ㄴ 객체를 생성하고 해당 Interface로 형식을 변환시 언터페이스 객체로 접근이 가능  ex) MyInterface IFace = new MyInterface(); IFace.Run();

ref(참조 매개 변수) : 매개 변수로 전달시 전달된 변수의 값이 복사되어 다른값으로 변경된다.

==================================================================
// DATE : 18.09.18
// NAME : MR.HAK
// KIND : C#
==================================================================
- GC.Collete(); // 되도록 사용 안하는걸 추천;
  모든 세대 (0 ~ 2세대) 를 수집한다. 
  => 메소드를 호출할때 마다 승급이 일어남,  0->1 1->2  2-> 할당된 메모리가 확장
  실 응용 프로그램에서 수십에서 수백개의 개체로 인하여 이러한 현상(특정때 마다 수집) 승급현상때문에 컬렉터가 더 하는일이 많아진다.
  해결 : 작은 공간을 자주 컬렉터가 수집하여 메모리를 회수하는 것이다. 

==================================================================
// DATE : 18.09.17
// NAME : MR.HAK
// KIND : C#
==================================================================
static Method 
  1. Class의 Instance 없이 호출이 가능하며, 인스턴스에서는 호출 할 수 없다.
  2. 유틸리티 함수를 만드는데 유용하게 사용  

==================================================================
// DATE : 18.09.14
// NAME : MR.HAK
// KIND : C#
==================================================================
abstract(추상) : 사용시 해당 클래스도 반드시 abstact 클래스 이여야한다. < 속성이나 메소드는 본문을 정의 불가능 > < public, protected만 사용 >  [주 일반클래스를 위한 부모클래스용도]
  ㄴ 어떤 클래스가 추상 클래스를 상속 받는다면 해당 클래스는 추상 클래스에 선언했던 추상 메서드를 무조건 구현을 해야하는 룰이 있습니다. 이 룰을 어기면 에러가 발생합니다.
virtual(가상) : 사용시 정적(static class)를 제외한 모든 클래스에서 사용이 가능 < 속성이나 메소드는 본문을 정의 가능 > < public, protected만 사용 > 
override : abstract or virtual 표시된 속성이나 메소드에서만 사 가능

목적, 추상 클래스의 목적은 여러 파생 클래스에서 공유할 수 있는 기본클래스의 공통적인 정의를 제공하는것

ex)
public class D
{
    public virtual void DoWork(int i)
    {
        // Original implementation.
    }
}

public abstract class E : D
{
    public abstract override void DoWork(int i);
}

public class F : E
{
    public override void DoWork(int i)
    {
        // New implementation.
    }
} 

★ abstract class / Interface 
  공통점 - 선언만 있고 구현내용은 없는 클래스
         - 인스턴스화 할 수 없다.
         - 자식 클래스가 무언가 반드시 구현하도록 위임해야할때 사용해야한다.
  차이점
         - 추상클래스는 단일상속 / 인터페이스는 다중 상속
         - 추상클래스는 상속을 받아서 기능을 확장시키는것(부모의 유전자)
         - 인터네이스는 구현하는 모든 클래스에 특정한 메소드가 반드시 존재하도록 강제하는 역할 (필요에 따른 결합 관계)
  

Link : https://slaner.tistory.com/160 
       https://donggyu9410.medium.com/%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EC%9D%98-%EC%B0%A8%EC%9D%B4-b238d1ad04e5
==================================================================
// DATE : 18.09.13
// NAME : MR.HAK
// KIND : C#
==================================================================
Application.LoadLevelAsync 와 Application.LoadLevel의 차이

LoadLevelAsync <비동기방식> 로딩을 백그라운드로 해서 미리 씬을 호출
LoadLevel 로딩없이 바로 한번에 호출 

Application.backgroundLoadingPriorty = UnityEngine.ThreadPriority.Low;
// Thread를 통하여 리소스를 느리게 호출

public class LoadingSceneManager : MonoBehaviour
{
    public static string nextScene;

    [SerializeField]
    Image progressBar;

    private void Start()    - 2
    {
        StartCoroutine(LoadScene());
    }

    string nextSceneName;   - 1
    public static void LoadScene(string sceneName)
    {
        nextScene = sceneName;
        SceneManager.LoadScene("LoadingScene");
    }

    IEnumerator LoadScene()   -3
    {
        yield return null;

        AsyncOperation op = SceneManager.LoadSceneAsync(nextScene);
        op.allowSceneActivation = false;

        float timer = 0.0f;
        while (!op.isDone)
        {
            yield return null;

            timer += Time.deltaTime;

            if (op.progress >= 0.9f)
            {
                progressBar.fillAmount = Mathf.Lerp(progressBar.fillAmount, 1f, timer);

                if (progressBar.fillAmount == 1.0f)
                    op.allowSceneActivation = true;
            }
            else
            {
                progressBar.fillAmount = Mathf.Lerp(progressBar.fillAmount, op.progress, timer);
                if (progressBar.fillAmount >= op.progress)
                {
                    timer = 0f;
                }
            }
        }
    }
}

==================================================================
// DATE : 18.09.12
// NAME : MR.HAK
// KIND : C#
==================================================================
UIRoot Commponent - Scaling Type value
1. Default - Flexible : UI 디바이스 상관없이 항상 같은 픽셀수를 유지한다. == 고해상도 Device UI가 작아보임 / 저해상도 Device UI가 커보임
2. Constrained : Device의 해상도가 지정한 해상도로 고정되게 보여짐
3. ConstrainedOnMobiles : 결합 Desktop에서는 Flexible / Mobile에서는 Constrained로 작동한다.
  Clipping
    - 특정 영역을 설정하고(연보라색 사각형), 해당 영역 밖의 부분은 렌더링 하지 않는것 

AsyncOperation
allowSceneActivation - (bool)장면이 준비된 즉시 장면이 활성화 허용
isDone - 해당 동작이 완료되었는지를 나타냄(OnlyRead)
priority - Priority는 동작할 비동기적인 작업 요청 순서를 수정하도록 변경가능
progress - 작업의 진행상태를 나타냄(OnlyRead)

CUIPopupBase -> base.DoUIShowPopup();

==================================================================
// DATE : 18.09.11
// NAME : MR.HAK
// KIND : C#
==================================================================
CUIManagerCommonPopup 사용시 주의사항
- 팝업 추가시 추가한 클래스와 동일한 이름의 클래스명을 EUIPopupCommon enum 타입으로 추가
  클래스 변수 = CUIManagerCommonPopup.Instance.DoUICommonPopupShow(클래스 enum 타입) as 클래스;
  변수.SetCallBackOnExit(Null)  <= 해당 팝업이 종료시에 나타날 이벤트에 대한 콜백 등록 

Service Function
cell(x) : x를 가장 가까운 정수로 올림 Double 타입으로 변환
floor(x): x를 가장 가까운 정수로 내림 Double 타입으로 변환
abs(x)  : x의 절대값을 반환

- cell(3.14);   // 4
- floor(1.89);  // 1
- abs(-123);    // 123
==================================================================
// DATE : 18.09.06
// NAME : MR.HAK
// KIND : C#
==================================================================
- GetHashCode
  객체를 식별하는 고유한 ID 
  ㄴ GetHashCode() 로 반환
  가용자가 GetHashCode() 재정의 가능하다.

- Equals 
  문자열 비교 패턴  ex string.Equals(string)  //  string .Equals(string, string) 두 개의 타입을 비교..
  

==================================================================
// DATE : 18.08.14
// NAME : MR.HAK
// KIND : C#
==================================================================
람다식(lambda) - 익명 메소드를 좀 더 쉽게 만들기 위해 사용
(매개변수_목록) => 식 
함수형 프로그래밍
- 장 : 코드에 불필요한 부분을 없애 코드가 짧아짐, 예상치 못한 불량을 줄임
- 단 : 코드의 이해가 난해함 및 어려움

Func Delegate : Return 값이 존재하는 익명 메소드 / 무명 함수를 위한 델리게이트
Action Delegate : Return 값이 존내하지 않은 익명 메소드 / 무명 함수를 위한 델리게이트

[ 추상클래스 ]
public abstract class A
{
    public virtual void DoWork(int nNum)
    {
    }
}

public abstract class B : A
{
    public abstract override void DoWork(int i);
}

public class C : B
{
    public override void DoWork(int i)
    {
        //New Implementation
    }
}

- 추상 클래스는 인스턴스화 할 수 없다.
- 목적 : 여러 파생 클래스에서 공유할 수 있는 기본 클래스의 공통적인 정의를 제공 하는것,
==================================================================
// DATE : 18.08.10
// NAME : MR.HAK 
// KIND : C#
==================================================================
Delegate =>  메소드를 대신해서 호출하는 역할 // 대리인의 역할을 해주는 변수
★ CallBack Method
== A 라는 메소드를 호출할때 B라는 메소드를 넘겨주어 A 메소드로 하여금 B메소드를 호출하도록 하는 것
  ex) A Mothod
    {
      Delegate();   <-  Delegate B Method
      // B Method Call (Call Back)
    }
Delegate는 B메소드를 참조하는 변수로써 A 메소드에게 넘겨지는 매개변수가 되고,
A메소드(CallBack Method)는 매개변수로서 받은 델리게이트로 B메소드를 호출한다, == CallBack
% Call Back 은 반대로 서비스를 제공해주는 쪽에서 요청하는 쪽의 특정 함수를 호출하게 되는 것입니다.
상하관계를 가지지 않더라도 무언가 이벤트가 일어났을때 알려줄수가 있다.
%Why Use It?
피동적인 액션을 취할때 사용 -> 누군가 나를 호출하므로서 내가 호출당하기 위해 사건에 개입하는 일이 없게되도록
  ㄴ 사건과 그로인한 행위를 분리할 수 있는것
  
foreach() Check 

==================================================================
// DATE : 18.08.08
// NAME : MR.HAK
// KIND : C#
==================================================================
https://docs.unity3d.com/kr/530/ScriptReference/MonoBehaviour.html

==================================================================
// DATE : 18.08.07
// NAME : MR.HAK
// KIND : C#
==================================================================

&& 클래스를 효과적으로 관리하는 방식

일반화(Generalization) ??
 ㄴ서로 다른 개념에서 공통점을 찾는 것...
ex) "ABC" = "가나다" 다른 글자이지만 문자라는 "공통점"을 가진다.
== 어떠한 개념에 대해서 포괄하는 공통된 개념을 찾아 서로 다른 개념을 하나로 묶어 줄수 있다.
void print(int A)         void print<T> (T value)
void print(float B)  =>     Console.WriteLine(value);
void print(string C)
'T 는 형식매개변수 라고 하여 변수 타입을 지정해주는 역할을 한다.'
'T는 단순히 치환을 해주는 문자이기 때문에 T외에 어떤 문자도 사용 가능하다 한글도 가능하다는데.....'
- 클래스도 일반환 클래스로 치환 가능

★ T 변수 제약조건
(( 특정 조건을 갖춘 타입으로만 치환이 가능하도록 제한)) == "Where T : 제약조건"
 ㄴ "Where T" 라는 건 T가 어디에 있어야 한다<속해야 한다> 라는 의미로 해석가능 
    ㄴ Where 이라는 키워드로 T의 타입 범위를 지정해주는 것.
`
"Where 형식매개변수 : 제약조건"
Where List<T> where T : class     // where T : class 라 하면 "형식 매겨변수 T의 타입은 class 여야 한다."
{ // ... }
void Print<K> where K : struct    // K 타입의 값 (int, float 등등...) 이어야 한다.
{ // ... }

Where T : new()           // T는 매개변수가 없는 생성자를 가진 타입이어야 한다.
Where T : 클래스이름      // T는 지정한 클래스이거나 이를 상속받는 클래스 이어야 한다.
Where T : 인터페이스이름  // T는 인터페이스를 상속받는 클래스 이어야 한다.
where T : U               // T는 형식매개변수 U의 타입이거나, 이를 상속받는 클래스이어야 한다.

where T Struct            // 형식 인수가 값 형식이어야 한다.
where T Class             // 형식 인수가 참조 형식이어야 한다.

** new 제약 조건은 제네릭 클래스 선언의 모든 형식 인수에 매개 변수가 없는 public 생성자가 있어야 하도록 지정합니다.
   새 제약 조건을 사용하려면 추상 형식일 수 없습니다.


class MyList<T> where T : MyClass  => Class의 형식 매개 변수 "T"에 "MyClass" 로 부터 상속받는 형식이여야 할 것
  private void CopyArray<T> (T[] t1, T[] t2 ) where T : struct  
    =>  일반화 메소드를 예로 들어 CopyArray<T>()의 형식 매개변수 T에 "값 형식이어야 할것" 이라는 제약을 줄 수 있다.
  
%% 형식매개변수 대한 제약조건을 사용하는 이유??
  제네릭 목록의 항목을 검사하여 그 유효성 여부를 확인하거나  이 항목 을다른 항목과 비교하는경우
  
  형식 매개 변수 제약을 통해 허용되는 작업 및 메소드 호출 수를 제약헝식 및 해당 상속 계층 구조의 모든 형식에서 지원하는 
  작업 및 메소드 호출로 늘린다. 