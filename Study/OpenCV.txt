%% OpenCV 영상처리를 위해 사용하는 라이브러리 ( 실시간 이미지 프로세싱 중점을 둔 Lib )
    OpenCV는 영상처리, 3D 구성, 추적, 기계학습, 인식 그리고 딥러닝까지 유용한 기능
  
  - OpenCV 는 영상처리 관련 알고리즘의 최적화와 뛰어난 메모리관리가 가능한 LIB 의 집합
  - 영상처리 속도를 개선하기 위하여 openCV에서는 참조 카운팅(reference counting) 시스템을 사용한다. 각각의 Mat 오브젝트들은 자신만의 매트릭스 헤더를 
    가지고있지만 매트릭스는 공유하여 같은 데이터 매트릭스를 다수의 Mat오브젝트에서 같이 사용하는 것이다. 이렇게 될시 Mat 오브젝트간에 매스릭스를 
    복사시 일일히 픽셀별로 값을 가져다 복사할 필요없이 매트릭스 헤더를 복사하고 매트릭스 포인터만 가리키게 하면 되므로 이미지 데이터 복사 속도가 개선된다.
    더이상 매트릭스를 사용하는 Mat 객체가 없을경우 메모리에서 해제된다.

Mat은 이미지를 저장하는 하나의 Class이며 이것은 크게 헤더와 데이터포인터로 구성되어 있다.
  ㄴ 헤더는 자기 자신에 저장되있는 이미지에 대한 정보를 담는곳 ex) 이미지 크기 , 포맷
  ㄴ 데이터 포맷은 이미지 하나하나의 픽셀이 담겨있는 메모리주소에 대한 정보를 가지고 있다.
  ㄴ Mat 을 사용시 더이상 수동으로 메모리를 할당하고 다시 해제하는 일이 발생하지 않는다.
    ㄴ 클래스 생성자에서 할당을 해주고 클래스 소멸자에서 해제를 해주게 되어있다,
//=============================================================================================

OpenCV 자주 사용하는 함수

- cvLoadImage   || 영상 읽기
  lpImage* cvLoadImage( const char* filename, int iscolor = 1 );
  *isColor 값 종류
  #define CV_LOAD_IMAGE_COLOR       1
  #define CV_LOAD_IMAGE_GRAYSCALE   0
  #define CV_LOAD_IMAGE_UNCHANGED  -1
  
- cvShowImage   || 영상 보기
  void cvShowImage( const char* name, const cvArr* Image );체
  
- cvSaveImage   || 영상 저장
  int cvSaveImage( const char* finename, const CvArr* image );
  
- cvNamedWindow   || 창 생성
  int cvNamedWindow( const char* name. int flags );
- cvMoveWindow    || 창 이동
  void cvMoveWIndow( const char* name, int x, int y );
- cvDestroyWindow   || 창 파괴
  void cvDestroyWindow( const char* name );
- cvDestroyAllWindows   || 모든 창 파괴
  void cvDestroyAllWindows();
- cvResizeWindow    || 창 크기 조절	
  void cvResizeWindow( const char* name, int width, int height );

영상 관련
- cvCreateImage	영상 데이터 할당	
  IplImage* cvCreateImage( CvSize size, int depth, int channels );
- cvReleaseImage	할당한 영상 데이터를 해제구조체를 삭제하고 메모리 반환	
  void cvReleaseImage( IplImage** image);
- cvCloneImage	영상 데이터 복제	
  IplImage* cvCloneImage( const IplImage* image );
- cvThreshold	영상의 이진화 수행하는 함수	
  void cvThreshold(const CvArr* src, CvArr* dst, double threshold, double max_value, int threshold_type);
  
매트릭스
- cvCreateMat	매트릭스 구조체를 만들어주는 함수	
  CvMat* cvCreateMat(int rows, int cols, int type);
- cvSetZero	매트릭스 모든 항을 0으로 만듬	
  void cvSetZero(CvArr* arr);
- cvmSet	매트릭스 항에 값을 쉽게 넣을 수 있음	
  CV_INLINE void cvmSet(CvMat* mat, int row, int col, double value);
- cvmGet	매트릭스 항의 값을 쉽게 얻을 수 있
  CV_INLINE void cvmGet(CvMat* mat, int row, int col);
  
카메라 처리 관련
- cvCreateCameraCapture = cvCaptureFromCAM	CvCapture 구조체 생성하고 그 포인터 반환, 카메라와 구조체 연결 역할	
  CvCapture* cvCreateCameraCapture(int index);
- cvGrabFrame	카메라에서 입력된 영상 한 프레임 잡음	
  int cvGrabFrame(CvCapture* capture);
- cvRetrieveFrame	잡은 프레임에서 이미지 얻어냄	
  IplImage* cvRetrieveFrame(CvCapture* capture);
- cvQueryFrame	카메라에서 한 프레임 잡아와서 이미지 구조체에 넘어줌	
  IplImage* cvQueryFrame(CvCapture* capture);
- cvReleaseCapture	CvCapture 구조체의 메모리 반환	
  void cvReleaseCapture(CvCapture** capture);
- cvCreateVideoWriter	비디오출력기 생성해주는 함수	
  CvVideoWriter* cvCreateVideoWriter(const char* filename, int fourcc, double fps, CvSize frame_size, int is_color CV_DEFAULT(1));
- cvWriteFrame	비디오 출력기에 이미지 넘겨줌	
  int cvWriteFrame(CvVideoWriter* writer, const IplImage* image);
- cvReleaseVideoWriter	비디오 출력기 메모리 반환	
  void cvReleaseVideoWriter(CvVideoWriter** writer);
  
그 외
- cvWaitKey	키 입력 받을 수 있도록 대기시간 가짐	
  int cvWaitKey(int delay CV_DEFAULT(0));
- cvSplit	영상의 채널을 각각의 싱글 채널 이미지 구조체에 자동적으로 분리	 
  void cvSplit(const CvArr* src, CvArr* dst0, CvArr* dst1, CvArr* dst2, CvArr* dst3);
- cvGetReal2D	지정한 좌표의 픽셀값 리턴	
  double cvGetReal2D(const CvArr* arr, int idx0, int idx1);
- cvSetReal2D	이미지 데이터의 어떤 좌표에 값을 넣어줌	
  double cvSetReal2D(const CvArr* arr, int idx0, int idx1);

//=============================================================================================
  
  
Mat Class
  숫자로 된 디지털화된 배열들은 모두 Mat 클래스로 구현한 행렬, 
  Mat 클래스로는 다채널 상수, 복소수, 행렬, 영상 등의 수치데이터를 표현하는 n 차원 행렬 클래스
  
  using namespace cv;

1. 이미지 읽기 & 저장

	Mat img_color = imread("sample.jpg");	// color load
	Mat img_gray = imread("sample.jpg", 0);// gray load
	imwrite("fname.jpg", img);

2. 이미지 생성, 복사, 형변환, 색상변환, roi 설정

	int w = 320;// width
	int h = 240;// height

	// 생성
	Mat img(h,w,CV_8UC1);                    //1채널 unsigned char
	Mat img(h,w,CV_8UC3);                    //3채널 unsigned char
	Mat img = Mat::zeros(h,w,CV_32FC1);//1채널 float
	Mat img = Mat::ones(h,w,CV_64FC3);//3채널 double

	unsigned char * img_buffer;            // 이미지버퍼 포인터

	Mat img(h, w, CV_8UC3, img_buffer);//메모리 공유
	// 원소 초기화
	Mat img(h,w,CV_8UC1);
	img = Scalar(3);                 // img 모든 원소값 3으로 초기화

	// 참조, 복사
	Mat img2 = img;	                // 메모리 공유
	Mat img2 = img.clone();	// 별도 메모리
	Mat img2; img.copyTo(img2);//별도 메모리	

	// 형변환 복사
	Mat img1(h,w,CV_32FC1);
	Mat img2;
	img1.convertTo(img2, CV_8U);

	// gray-color 변환
	cvtColor(color, gray, CV_BGR2GRAY);
	cvtColor(gray, color, CV_GRAY2BGR);

	// roi 설정
	Rect roi;
	Mat sub_img = img(roi);                //메모리공유
	Mat sub_img = img(roi).clone();    //별도메모리

3. 영상 크기변경 및 상하좌우 반전
	// 크기 변경
	Mat dst;
	resize(img, dst, Size(new_w,new_h));
	resize(img, dst, Size(), 0.5, 0.5);    //scalex, scaley

	// 영상 반전(flip)
	flip(img, dst, 0);        // vertical flip
	flip(img, dst, 1);        // horizontal flip
	flip(img, dst, -1);       // vertial & horizontal flip

4. 이미지에 그리기 (drawing)
	Rect rc(x,y,w,h);
	Scalar color(B,G,R);
	int thickness=1;	        // line thickness

	line(img, Point(x1,y1), Point(x2,y2), color, thickness);

	rectangle(img, rc, color, thickness);
	rectangle(img, rc.tl(), rc.br(), color, thickness);
	rectangle(img, rc, color, CV_FILLED);	// filled rectangle

	Point center(rc.x+rc.width/2, rc.y+rc.height/2);
	Size radius(rc.width/2, rc.height/2);
	double rot_deg = 0;	    // rotation of ellipse
	double s_deg = 0;	    // start angle of arc
	double e_deg = 360;	    // end angle of arc
	ellipse(img,center,radius,rot_deg,s_deg,e_deg,color,thickness);
	ellipse(img,center,radius,rot_deg,s_deg,e_deg,color,CV_FILLED);

	int circle_radius = 10;
	circle(img, center, circle_radius, color, thickness);
	circle(img, center, circle_radius, color, CV_FILLED);

	putText(img, "text", Point(x,y), FONT_HERSHEY_SIMPLEX, 1., color, thickness);
	putText(img, "text", Point(x,y), FONT_HERSHEY_DUPLEX, 1., color, thickness);

5. 이미지 디스플레이하기 (display)
	namedWindow("name");	                                // auto resized
	namedWindow("name",CV_WINDOW_NORMAL);	// manual resize

	imshow("name", img);
	char ch = waitKey();	    // 무한 대기
	char ch = waitKey(10);    // 10 msec 대기
	if(ch == 27) ...	            // ESC key
	if(ch == 32) ...	            // SPACE key

	destroyWindow("name");
	destroyAllWindows();

6. 웹캠 연결하기

	VideoCapture vc(0);
	if (!vc.isOpened()) return; // 연결실패
	vc.set(CV_CAP_PROP_FRAME_WIDTH, 640);
	vc.set(CV_CAP_PROP_FRAME_HEIGHT, 480);

	Mat img;
	
	while(1)
	{
		vc >> img;
		if(img.empty()) break;
		imshow("cam",img);
		if(waitKey(10)==27) break; //ESC
	}
	destroyAllWindows();

7. avi 비디오 파일 읽어오기
	VideoCapture vc("sample.avi");
	if (!vc.isOpened()) return; // 불러오기 실패

	Mat img;
	while(1)
	{
		vc >> img;
		if(img.emplty()) break;
		imshow("video",img);
		if(waitKey(10)==27) break; //ESC
	}
	destroyAllWindows();

8. avi 비디오 녹화하기
	double fps = 15;
	int fourcc = CV_FOURCC('X','V','I','D'); // codec
	bool isColor = true;

	VideoWriter *video = new VideoWriter;
	if(!video->open("result.avi", fourcc, fps, Size(img_w, img_h), isColor))
	{
		delete video;
		return;
	}

	Mat img;
	while(1){
		// ...
		*video << img;
		// ...
	}

	delete video;

9. Mat <--> IplImage
	Mat --> IplImage

	Mat matimg;
	IplImage* iplimh;
	iplimg = &IplImage(matimg);

	IplImage --> Mat

	IplImage* iplimg;
	Mat matimg;
	matimg(iplimg);
  
10. 픽셀 접근법
  Mat image;