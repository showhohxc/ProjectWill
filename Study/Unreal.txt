Category              Unity                 Unreal
게임플레이          Component             Component
                    GameObject            Actor 액터, Pawn 폰
                    Prefab                Blueprint Class 블루프린트 클래스

에디터 UI           Hierarchy Panel       World Outliner 월드 아웃라이너
                    Inspector             Details Panel 디테일 패널
                    Project Browser       Content Browser 콘텐츠 브라우저
                    Scene View            ViewPort 뷰포트

메시                Mesh                  Static Mesh 스태틱 메시
                    Skinned Mesh          Skeletal Mesh 스켈레탈 메시

머테리얼            Shader                Material, Material Editor
                    Material              Meterial Instance

이펙트              Particle Effect       Effect, Particle, Cascade
                    Shuriken              Cascade

게임 UI             UI                    UMG(Unreal Motion Graphics)

애니메이션          Animation             Skeletal Animation System 스켈레탈 애니메이션 시스템
                    Mecanim               Persona, Animation Blueprint

2D                  Sprite Editor         Paper2D

피직스              Raycast               Line Trace, Shape Trace
                    Rigid Body            Collision, Physics

Actor : Pawn : Character

Actor : 액터는 언리얼 엔진의 레벨에 배치할 수 있는 오브젝트를 의미하고 Gameobject와 근접한 오브젝트이다.

Pawn : 폰은 플레이어나 AI가 제어할 수 있는 모든 액터의 베이스
게임을 하게되면 내가 조작할 수 있는 오브젝트들이 있다. 
대표적으로 내가 키보드를 통해 움직임을 명령하는 캐릭터같은 플레이어(혹은 AI)가 명령을 내리고 그것에 따라서 움직이는 액터들을 Pawn이라고 하는 것! 
따라서 Actor보다 더 구체적으로 정의된 오브젝트 클래스라는 것이다. Pawn 생성시 자동으로 APwan 클래스를 상속받는다, 즉 Pawn은 좀 더 구체적인 액터

Character : APwan에서 좀 더 복잡한 애니메이션을 위해 파생된 클래스, 

AC -> r > Pawn > Character

//================================================================================================================

Actor
ㄴ 모빌리티
  ㄴ 스태틱 : 게임플레이 도중 어떤 식으로도 이동 or 변화할수 없는 액터
  ㄴ 스테이셔너리 : 움직이지 않는 라이트 액터에 사용 or 게임 플레이 도중 스위치를 켜고 끌때 사용
  ㄴ 무버블 : 게임플레이 도중 이동시켜야 하는 액터

PlayerController는 Pawn과 그것을 제어하려는 사람사이의 인터페이스 == Player의 의지를 대변하는 클래스,
PlayerController는 Controller 클래스를 상속받고, Process() 함수로 Pawn의 제어권을 획득, UnProcess() 함수로 제어권 포기
                    
//================================================================================================================

C++ 클래스 생성시 BeginPlay() 와 Tick을 기본으로 오버로딩하는 클래스를 생성하는데 BeginPlay() == Awake() / Tick() == Update() 
사용하지 않을경우 제거하는 편이 퍼포먼스가 향상된다

에디터에서 설정할수 있는 프로퍼티 public == UPROPERTY(EditAnywhere, 변수 ) // 블루프린트 노출시 UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Damage" )

UObject 및 가비지 컬렉션
가비지 컬렉션 시스템 구현을 위해 리플렉션 시스템을 사용, GC 덕에 UObject 삭제를 수동 관리할 필요 없이, 그냥 그에 대한 유효 레퍼런스만 유지해 주면 된다.
< UObject 파생 클래스여야 GC 가 활성화 된다 > 
ex) class MYGCType : public UObject
{
  GENERATED_BODY()
};

액터는 보통 GC 에 컬렉팅 되지 않기 때문에 스폰 후 반드시 거기서 Destroy()를 수동 호출해야한다. 즉시 삭제되는것은 아니며 다음 가비지 GC단계에서 지워진다.

//================================================================================================================
UE4 블루프린트 클래스는 확장 가능
Unity Prefab 과 UE4 블루프린트 클래스는 게임에서 비슷하게 인스턴 스 생성이 가능
  ㄴ But, ! Unity 의 경우 한 프리팹을 다른 프리팹 안에 중첩시키는 경우 복잡해져서, 확장형 구성 요소로서의 역할이 제한
    ㄴ UE4 의 경우 블루프린트 클래스를 새로 만들고, 기존 블루프린트 클래스를 확장하여 새로운 프로퍼티, 비주얼 스크립트 함수성으로 살을 붙이는것이 가능
        ㄴex) 사람들을 쫒거나 하는 기본적인 적의 함수성을 구현하는 Monster 이름의 블루프린트 클래스를 만들고 그후 블루프린트 클래스를 확장이 가능
              Dragon으로 하여 불을 내뿜는 기능을 추가하고 Grue 라고 하여 밤이 되면 사람을 먹는 기능을 추가하고, 이런 식으로 8개 더 만든후 , 
              이러한 Monster의 서브클래스는 모두 Monster의 기본적인 함수성을 상속하고, 그위에 새로운 기능이 추가된다.
              
              UE4 에서는 그냥 Monster 블루프린트 클래스를 편집하여 대화 능력을 추가해 주기만 하면 됩니다.
              끝! Dragon, Grue, 나머지 8 종의 Monster 서브클래스 모두 자동으로 새로운 대화 함수성을 상속하므로, 일일이 건드릴 필요 없습니다.

//================================================================================================================
% 언리얼엔진은 상속에 대한 이해도 필요
//================================================================================================================

FString str = FString::printf(TEXT("텍스트%f\n"), distance);

//================================================================================================================

Volume System에 대한 이해 

1. Blocking Volume == Collision 표면
2. Camera Blocking Vloume : 카메라만 막고 다른 모든 것들을 무시하도록 미리 설정된 Collision Setting Volume. 
  카메라가 안좋은 위치에 오지 않도록 보이지 않는 장벽의 역할, ex) 카메라 블로킹 볼륨을 벽에 배치하면 카메라가 덩굴이나 잎사귀 뒤로 넘어가지 않드록 하여
  부드럽게 미끄러지며 방의 동작을 방해받지 않고 볼 수 있도록 설정 할 수 있다.
3. FMath::Sin 은 FMath 클래스의 sin 함수를 사용 " :: 상속을 받거나 오는것 " 의미 
FMath::abs <절대값> 

//================================================================================================================

CreateDefaultSubobject 메소드에서 사용하는 첫 번째 문자열 인자는 서브오브젝트를 관리하기 위한 내부 해쉬(Hash)값을 생성하는데 사용
그러므로 아무 문자열 값을 상요해도 무방하지만, 다른 서브오브젝트를 생성할때 이전에 사용한 값을 사용하면 안된다. 언리얼엔진이 뻗는다.

AddControllerYawInput  <- ->  : 마우스의 움직임에 따라 컨트롤러의 컨트롤 회전값을 설정 컨트롤러 회전에 따라 캐릭터/카메라가 일정한 속도로 회전하는 기능 제작
AddControllerPitchInput ↑ ↓

//================================================================================================================
// Character 상태값 체크

m_Pawn->GetMovementComponent()->IsFalling();  // 공중에 떠 있는지 => 
m_Pawn->GetMovementComponent()->IsSwiming();  // 현재 수영중인지
m_Pawn->GetMovementComponent()->IsCrouching();  // 쭈구려 있는지
m_Pawn->GetMovementComponent()->IsMoveOnGround();  // 땅 위에서 이동중인지

//================================================================================================================

프로퍼티 지정자	설명
BlueprintReadWrite	 이 프로퍼티는 블루프린트에서 읽거나 쓸 수 있습니다. BlueprintReadOnly 지정자와 호환되지 않습니다.
 위 지정자를 사용하면 블루프린트 에디터 내 내 블루프린트 패널 또는 우클릭 액션 목록에서 'Get/Set 변수명'을 이벤트 그래프 또는 함수 창에서 사용할 수 있음을 의미합니다.
BlueprintReadOnly	 이 프로퍼티는 블루프린트에서 읽을 수는 있지만 변경은 안됩니다. BlueprintReadWrite 지정자와 호환되지 않습니다.
 위 지정자를 사용하면 블루프린트 에디터 내 내 블루프린트 패널 또는 우클릭 액션 목록에서 'Get 변수명'을 이벤트 그래프 또는 함수 창에서 사용할 수 있음을 의미합니다.
BlueprintSetter =SetterFunctionName	 이 프로퍼티에는 커스텀 뮤테이터(Mutator, Setter 다른 말) 함수가 있으며, 묵시적으로 BlueprintReadWrite 지정자가 붙습니다. 참고로 뮤터이터 함수는 같은 클래스 이름으로 그 일부를 따서 지어야 합니다.
 BlueprintReadWrite를 바탕으로 블루프린트에서 변수를 Set할 때 SetterFunctionName 함수를 Setter 함수로 실행시킨다는 것을 의미합니다.
BlueprintGetter =GetterFunctionName	 이 프로퍼티에는 커스텀 액세서(Accessor, Getter의 다른말) 함수를 지정합니다. 또한 BlueprintSetter 또는 BlueprintReadWrite 지정자가 지정되지 않으면, BlueprintReadOnly로 간주합니다.
 블루프린트에서 변수를 Get할 때 GetterFunctionName 함수를 Getter 함수로 실행시킨다는 것을 의미합니다.
EditorAnywhere	 이 프로퍼티는 아키타입이나 인스턴스 양쪽의 프로퍼티 창에서 편집할 수 있습니다. 이 지정자는 어떤 "Visible" 지정자와도 호환되지 않습니다.
 레벨에 배치된 클래스를 클릭했을 때 나오는 디테일 창 및 블루프린트 에디터의 디테일 창에서 해당 변수가 노출되며, 편집가능한 상태가 됩니다.
VisibleAnywhere	 이 프로퍼티는 모든 프로퍼티 창에서 보이지만 편집할 수 없음을 나타냅니다. 이 지정자는 어떤 "Edit" 지정자와도 호환되지 않습니다.
 레벨에 배치된 클래스를 클릭했을 때 나오는 디테일 창 및 블루프린트 에디터의 디테일 창에서 해당 변수가 노출되지만, InputField가 회색으로 블록되어 편집할 수 없습니다.
EditDefaultsOnly	 이 프로퍼티는 프로퍼티 창에서 편집할 수 있지만, 아키타입 상에서만 가능합니다. 이 지정자는 어떤 "Visible" 지정자와도 호환되지 않습니다.
 블루프린트 에디터의 디테일 창에서만 해당 변수가 노출되며, 편집가능한 상태가 됩니다.
VisibleDefaultsOnly	 이 프로퍼티는 아키타입에 대한 프로퍼티 창에서 보이기만 할 뿐, 편집할 수는 없음을 나타냅니다. 이 지정자는 어떤 "Edit" 지정자와도 호환되지 않습니다.
 블루프린트 에디터의 디테일 창에서만 해당 변수가 노출되며, InputField가 회색으로 블록되어 편집할 수 없습니다.
EditInstanceOnly
 이 프로퍼티는 프로퍼티 창에서 편집할 수 있지만, 아키타입이 아닌 인스턴스 상에서만 가능합니다. 이 지정자는 어떤 "Visible" 지정자와도 호환되지 않습니다.
 레벨 에디터에 배치된 인스턴스의 디테일 창에서만 해당 변수가 노출되며, 편집가능한 상태가 됩니다.
VisibleInstanceOnly
 이 프로퍼티는 아키타입이 아닌 인스턴스에 대한 프로퍼티 창에서 보이기만 할 뿐, 편집할 수는 없음을 나타냅니다. 이 지정자는 어떤 "Edit" 지정자와도 호환되지 않습니다.
 레벨 에디터에 배치된 인스턴스의 디테일 창에서만 해당 변수가 노출되며, InputField가 회색으로 블록되어 편집할 수 없습니다.
Category=" TopCategory| SubCategory|..."	 블루프린트 편집 툴에 이 프로퍼티를 표시할 때의 카테고리르 지정합니다. 중첩 카테고리는 | 연산자로 정의합니다.
 블루프린트의 내 블루프린트 패널, 우클릭 액션 목록, 디테일 창 등 표시될 수 있는 곳에 카테고리가 매겨집니다.
메타데이터 지정자	설명
AllowPrivateAccess =true	 정의되지 않음
 C++ 코드상에서 private 접근 한정자로 수식된 변수에 대해 접근을 허용하여, 블루프린트 상에 노출시킬 수 있도록 돕습니다.
 
 
//================================================================================================================

언리얼 엔진에서 플레이 중인 게임의 정보를 처리하는 클래스는 크게 [게임 모드]와 [게임 스테이트], 둘로 나뉜다. 매우 간단한 게임일지라도 게임을 통제하는 규칙은 존재하며 이러한 규칙들이 게임 모드를 이룬다. 
기본적으로 게임 모드에 포함되는 규칙들의 예시는 다음과 같다.
- 존재하는 플레이어와 관람자의 수는 물론, 허용된 플레이어와 관람자 최대 수
- 플레이어가 게임에 들어오는 방식, 스폰 위치 선택 규칙과 기타 스폰/리스폰 동작 포함 가능
- 게임 일시정지 가능 여부, 게임 일시정지 처리 방식
- 레벨간의 전환, 게임의 시네마틱 모드 시작 여부 포함
이러한 게임 모드에서 관리하는 규칙의 특징은 [게임 중에 변하지 않을 정보 const]들이라는 것이다. 
자주 혹은 종종 변경될 수 있는 정보는 게임 모드에서 관리하지 않는 것이 좋다. 
또한 게임 형식, 미션 유형, 특별 지역 규칙 등(예를 들어 하나의 FPS 게임 내에 데스매치, 폭파 임무, 점령전 등이 있는 식)에 따라 AGameModeBase의 서브클래스를 생성할 수 있다. 
한 게임에 여러 게임 모드가 있을 수 있지만, 한 번에 하나의 게임 모드만 사용할 수 있다.

반면 게임에 규칙 관련 이벤트가 발생하고 트래킹을 통해 정보를 모든 플레이어가 공유할 필요가 있을 때, 
그 정보는 게임 스테이트에 보관되고 그를 통해 동기화된다. 그 정보의 예시는 다음과 같다.
- 게임 실행 기간 (로컬 플레이어 참가 전 실행 시간 포함).
- 각 플레이어의 게임 참가 기간, 그 플레이어의 현재 상태.
- 현재 게임 모드의 베이스 클래스.
- 게임 시작 여부.

· 게임 모드
UE 4.14 버전부터 AGameModeBase가 도입되었다. 이는 모든 게임 모드의 베이스 클래스로, 고전 AGameMode 클래스를 단순화하고 효율화시킨 버전이다. 4.14 이전의 게임 모드 베이스 클래스였던 AGameMode는 기능도 그대로이고 사용하는 방법도 똑같지만 이젠 AGameModeBase의 자손이 되었다.
AGameMode는 경기 상태 개념 구현 방식상 멀티플레이어 슈팅 게임과 같은 유형에 보다 적합하다. EnteringMap(맵 진입), WaitingToStart(시작 대기 중), InProgress(진행 중), WaitingPostMatch(경기 후 대기) 등 경기 상태에 대한 부가 함수를 지원하며, 자세한 내용은 https://docs.unrealengine.com/4.27/ko/InteractiveExperiences/Framework/GameMode/의 'AGameMode' 항목에 자세히 나와 있다.

· 게임 스테이트
게임 스테이트는 클라이언트가 게임의 상태를 모니터링할 수 있도록 해준다. 접속한 모든 클라이언트가 알아야 하는 정보, 플레이어 개개인이 아닌 게임 모드에 관련된 정보를 관리해야 한다. 따라서 접속한 플레이어 목록, 팀의 게임 점수, 오픈 월드 게임에서 완료한 미션 등 다양한 게임 전반적인 프로퍼티 기록을 유지할 수 있다.
FPS 게임에서 팀 킬 스코어 중 특정 플레이어의 킬 스코어가 몇 점인지와 같은 개별 플레이어의 기록을 유지하기 좋은 곳은 아니다. 그런 내용은 플레이어 스테이트에서 보다 깔끔하게 처리할 수 있다. 일반적으로 게임 스테이트는 게임플레이 도중 변하면서 모두에게 관련이 있고 보일 수 있는 프로퍼티 기록을 유지해야 한다. 게임 모드는 서버에만 존재하지만 게임 스테이트는 서버에 존재하면서 모든 클라이언트에 리플리케이트되어, 연결된 모든 기기의 게임 최신 상태를 유지한다.
AGameStateBase가 기본 구현이며, 게임에서 무슨 일이 벌어지고 있는지 플레이어에게 지속적으로 알리기 위해 필요한 변수와 함수를 넣기 위해 C++ 또는 블루프린트로 자주 확장시키는 클래스이다.


//================================================================================================================

BluePrint
Construct object from Class 생성은 new 생성과 동일 

* <- 
일반적으로 정수 or float bool 와 같이 매우 기본적인 기본 유형이 아닌것은 더 효율적이고 실제로 필요하기 때문에 포인터를 사용합니다.

SetActorLocation(FVector(0, 0, 0))  액터 위치 설정

	EditInstanceOnly	: 레벨 에디터 디테일 창에서만 변수가 노출, 편집가능 
	VisibleInstanceOnly : 레벨 에디터 디테일 창에서만 변수가 노출, 편비 불가능

	EditDefaultsOnly	: 블루프린트 에디터의 디테일 창에서만 해당 변수 노출, 편집가능
	VisibleDefaultsOnly : 블루프린트 에디터의 디테일 창에서만 해당 변수 노출, 편집불가능